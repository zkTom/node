<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <!--code here-->
    <meta name="viewport" content="width=device-width,user-scalable=no">
    <title>effect demo</title>
    <style>
    </style>
</head>

<body>
    <div id="app"></div>
</body>
<script src="./reactivity.global.js"></script>
<script>
    const { ITERATE_KEY, computed, effect, isReactive, isReadonly, isRef, lock, markNonReactive, markReadonly, pauseTracking,
        reactive, readonly, ref, resumeTracking, stop, toRaw, toRefs, unlock } = VueObserver;

    // example 1
    (function () {
        // 在effect中可以进行依赖收集
        let dummy;
        const counter = reactive({ num: 0 })
        console.log('-- example 1 --')
        effect(() => {
            console.log('should run first time');
        });
        effect(() => {
            dummy = counter.num;
        })
        console.log(dummy); // 0
        counter.num = 7;
        console.log(dummy);// 7
    })();
    // example 2
    (function () {
        // 在effect中可以对多个属性进行依赖响应
        // 多个effect也可以对一个属性进行依赖响应
        let dummy, dummy1
        const counter = reactive({ num1: 0, num2: 0 })
        effect(() => dummy1 = counter.num1)
        effect(() => (dummy = counter.num1 + counter.num2))
        console.log('-- example 2 --')
        console.log(dummy, dummy1)// 0 0
        counter.num1 = 7
        counter.num2 = 9
        console.log(dummy, dummy1) // 16 7
    })();
    // exmaple 3
    (function () {
        // effect中可以对嵌套属性进行依赖响应
        let dummy
        console.log('-- example 3 --')
        const counter = reactive({ nested: { num: 0 } })
        effect(() => (dummy = counter.nested.num))
        console.log(dummy)// 0
        counter.nested.num = 7
        console.log(dummy)// 7
    })();
    // exmaple 4
    (function () {
        // 可以监测delete操作符
        // 可以监测in操作符
        // 可以监测原型链上的属性
        let dummy
        const obj = reactive({ prop: 'value' })
        effect(() => (dummy = obj.prop))
        console.log('-- example 4 --')
        console.log(dummy)// value
        delete obj.prop
        console.log(dummy)// undefined
        console.log('prop' in obj) // false
        obj.prop = 'value'
        console.log(dummy)// value
        console.log('prop' in obj)// true
        const parentObj = reactive({ prop: 'patent value' })
        Object.setPrototypeOf(obj, parentObj)
        effect(() => (dummy = obj.prop))
        console.log(dummy)// value
        delete obj.prop
        console.log(dummy)// parent value
        parentObj.prop = 'parent value1'
        console.log(dummy)
        obj.prop = 'value'
        console.log(dummy)// value
    })();
    // example 5
    (function () {
        let dummy
        const counter = reactive({ num: 0 })
        effect(() => (dummy = getNum()))

        function getNum() {
            return counter.num
        }
        console.log('-- example 5 --')
        console.log(dummy)// 0
        counter.num = 1
        console.log(counter.num)// 1
    })();
    // example 6
    (function () {
        // 可以监测数组变化 push + shift + pop
        // 可以监测数组的隐式变化arr[5] = ...
        let dummy
        const list = reactive(['Hello'])
        effect(() => (dummy = list.join(' ')))
        console.log('-- example 6 --')
        console.log(dummy)// Hello
        list.push('World!')
        console.log(dummy)// Hello World!
        list.shift()
        console.log(dummy)// World!
        list[1] = 'I am coming';
        console.log(dummy)// World! I am coming
        // 可以监测数组的循环变化
        dummy = 0
        const numbers = reactive({ num1: 3 })
        effect(() => {
            dummy = 0
            for (let key in numbers) {
                dummy += numbers[key]
            }
        })
        console.log(dummy)// 3
        numbers.num2 = 4
        console.log(dummy)// 7
        delete numbers.num1
        console.log(dummy)// 4
    })();
    // example 7
    (function() {
        // 可以使用Symbol key作为 值
        const key = Symbol('symbol keyed prop')
        let dummy, hasDummy
        const obj = reactive({ [key]: 'value' })
        effect(() => (dummy = obj[key]))
        effect(() => (hasDummy = key in obj))
        console.log('-- example 7 --')
        console.log(dummy);// value
        console.log(hasDummy)// true
        obj[key] = 'newValue'
        console.log(dummy)// newValue
        console.log(hasDummy)// true
        delete obj[key]
        console.log(dummy)// undefined
        console.log(hasDummy)// false
    })();
    // example 8
    (function() {
        const oldFunc = () => {}
        const newFunc = () => {}

        let dummy
        const obj = reactive({ func: oldFunc })
        effect(() => (dummy = obj.func))
        console.log('-- example 8 --')
        console.log(dummy === oldFunc)// true
        obj.func = newFunc
        console.log(dummy === newFunc)// true
    })();
    // example 9
    (function() {
        // 非'reactive' or ‘ref' 属性不会进行依赖调用
        let dummy
        const obj = reactive({})
        effect(() => (dummy = toRaw(obj).prop))
        console.log('-- example 9 --')
        console.log(dummy)// undefined
        obj.prop = 'value'
        console.log(dummy)// undefined
    })();
    // example 10
    (function() {
        // 非'reactive' or ‘ref' 属性不会进行依赖调用
        let dummy
        const obj = reactive({})
        effect(() => (dummy = obj.prop))
        console.log('-- example 10 --')
        console.log(dummy)// undefined
        toRaw(obj).prop = 'value'
        console.log(dummy)// undefined
    })();
    // example 11
    (function() {
        // 不可以被继承的getters所触发,只能由自己的setter/getter触发
        console.log('-- example 11 --')
        let dummy, parentDummy, hiddenValue;
        const obj = reactive({});
        const parent = reactive({
            set prop(value) {
                hiddenValue = value
            },
            get prop() {
                return hiddenValue;
            }
        })
        Object.setPrototypeOf(obj, parent)
        effect(() => (dummy = obj.prop))
        effect(() => (parentDummy = parent.prop))
        console.log(dummy)// undefined
        console.log(parentDummy)// undefined
        toRaw(obj).prop = 1
        console.log(dummy)// undefined
        console.log(parentDummy)// undefined
    })();
    // example 12
    (function() {
        console.log('-- example 11 --');
        const counter = reactive({ num: 0 })
        effect(() => counter.num++)// 这个函数只会执行一遍，不会循环调用
        console.log(counter.num)// 1 
    })();
    // 这个测试的是？
    // it('should not observe set operations without a value change', () => {
    //     let hasDummy, getDummy
    //     const obj = reactive({ prop: 'value' })

    //     const getSpy = jest.fn(() => (getDummy = obj.prop))
    //     const hasSpy = jest.fn(() => (hasDummy = 'prop' in obj))
    //     effect(getSpy)
    //     effect(hasSpy)

    //     expect(getDummy).toBe('value')
    //     expect(hasDummy).toBe(true)
    //     obj.prop = 'value'
    //     expect(getSpy).toHaveBeenCalledTimes(1)
    //     expect(hasSpy).toHaveBeenCalledTimes(1)
    //     expect(getDummy).toBe('value')
    //     expect(hasDummy).toBe(true)
    // })
</script>

</html>